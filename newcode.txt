/*
 * MaxLink - Traçabilité poches IBC - Platform v2.3 NeoPixel + Health Check
 * ESP32-S3 Feather | Scanner Datalogic GFS4150-9 | ILI9341 2.2"
 * 
 * NeoPixels RGBW (10 LEDs) : 0-7 monitoring global, 8=MQTT, 9=WiFi
 * Health Check Auto-Reconnexion (non-bloquant) toutes les 5s
 * Backoff exponentiel pour éviter flood
 * 
 */

#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
#include <Adafruit_NeoPixel.h>
#include <HardwareSerial.h>
#include <time.h>
#include <sys/time.h>

const char* ssid = "MaxLink-NETWORK";
const char* password = "MDPsupersecret007";

const char* mqtt_server = "192.168.4.1";
const int mqtt_port = 1883;
const char* mqtt_user = "mosquitto";
const char* mqtt_password = "mqtt";
const char* mqtt_topic = "SOUFFLAGE/ESP32/RTP";
const char* mqtt_client_id = "MaxTrace_ESP32_RTP";

#define TFT_CS          5
#define TFT_DC          6
#define TFT_RST         9
#define TFT_MOSI        35
#define TFT_SCK         36
#define TFT_MISO        37
#define TFT_LITE        10

#define CONTACT_OK      A1
#define CONTACT_FV      A2
#define CONTACT_FP      A3
#define BUTTON_PIN      12

#define NEOPIXEL_PIN    13
#define NEOPIXEL_COUNT  10

#define SCREEN_WIDTH    320
#define SCREEN_HEIGHT   240
#define TOP_BAR_HEIGHT  50
#define STATUS_BAR_HEIGHT 25
#define LOG_START_Y     75
#define LOG_HEIGHT      165
#define LOG_LINE_HEIGHT 10
#define MAX_LOG_LINES   (LOG_HEIGHT / LOG_LINE_HEIGHT)

#define TOP_BAR_TEAM_X         15
#define TOP_BAR_TEAM_Y         8
#define TOP_BAR_TEAM_SIZE      5

#define TOP_BAR_SEPARATOR_1_X  55

#define TOP_BAR_DATE_X         70
#define TOP_BAR_DATE_Y         6
#define TOP_BAR_TIME_Y         29
#define TOP_BAR_DATETIME_SIZE  2

#define TOP_BAR_SEPARATOR_2_X  190

#define TOP_BAR_APP_X          200
#define TOP_BAR_APP_Y1         5
#define TOP_BAR_APP_Y2         25
#define TOP_BAR_APP_SIZE       2

#define COLOR_HEADER      0xFC00
#define COLOR_ORANGE      0xFC00
#define COLOR_SUCCESS     ILI9341_GREEN
#define COLOR_WARNING     ILI9341_YELLOW
#define COLOR_ERROR       ILI9341_RED
#define COLOR_INFO        ILI9341_CYAN
#define COLOR_BACKGROUND  ILI9341_BLACK

#define BACKLIGHT_PWM_MAX     255
#define BACKLIGHT_PWM_MIN     0
#define BACKLIGHT_TIMEOUT     60000
#define BACKLIGHT_FADE_STEP   5
#define BACKLIGHT_FADE_DELAY  20

#define BUTTON_SHORT_PRESS  50
#define BUTTON_LONG_PRESS   2000
#define BUTTON_DEBOUNCE     50

enum ButtonState {
  BTN_IDLE,
  BTN_PRESSED,
  BTN_SHORT_DETECTED,
  BTN_LONG_DETECTED
};

enum LEDState {
  LED_INIT,
  LED_CONNECTING_WIFI,
  LED_TIME_SYNC,
  LED_READY,
  LED_SCANNING,
  LED_TEST_RUNNING,
  LED_SENDING,
  LED_SUCCESS,
  LED_ERROR
};

enum ConnectionState {
  CONN_IDLE,
  CONN_CONNECTING,
  CONN_CONNECTED,
  CONN_FAILED
};

struct RGBWColor {
  uint8_t r, g, b, w;
};

#define COLOR_BLUE          {0, 0, 255, 0}
#define COLOR_GREEN         {0, 255, 0, 0}
#define COLOR_YELLOW        {255, 255, 0, 0}
#define COLOR_ORANGE        {255, 128, 0, 0}
#define COLOR_RED           {255, 0, 0, 0}
#define COLOR_WHITE         {0, 0, 0, 255}
#define COLOR_CYAN          {0, 255, 255, 0}

Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_RST);
Adafruit_NeoPixel leds(NEOPIXEL_COUNT, NEOPIXEL_PIN, NEO_GRBW + NEO_KHZ800);
WiFiClient espClient;
PubSubClient mqtt(espClient);

String currentBarcode = "";
bool barcodeReceived = false;

struct TestData {
  String barcode;
  String result;
  String team;
} currentTest;

String barcodeBuffer = "";
unsigned long lastScanTime = 0;
unsigned long lastBarcodeTime = 0;
String lastBarcode = "";
const unsigned long SCAN_TIMEOUT = 500;
const unsigned long BARCODE_COOLDOWN = 2000;
const unsigned long SCAN_DEBOUNCE = 100;

String logBuffer[MAX_LOG_LINES];

bool timeSync = false;
unsigned long timeSyncStart = 0;
const unsigned long TIME_SYNC_TIMEOUT = 30000;

ButtonState buttonState = BTN_IDLE;
unsigned long buttonPressStart = 0;
bool buttonPressed = false;
bool lastButtonState = HIGH;

int backlightLevel = BACKLIGHT_PWM_MAX;
unsigned long backlightTimer = 0;
bool isBacklightActive = true;
bool backlightFading = false;

String systemStatus = "Initialisation";
String wifiStatus = "Deconnecte";
String mqttStatus = "Deconnecte";
long wifiRSSI = 0;

LEDState currentLEDState = LED_INIT;
uint8_t neoPixelBrightness = 100;
unsigned long lastLEDUpdate = 0;
float animationPhase = 0.0f;

unsigned long lastWiFiScan = 0;
const unsigned long WIFI_SCAN_INTERVAL = 5000;

ConnectionState wifiState = CONN_IDLE;
ConnectionState mqttState = CONN_IDLE;

unsigned long lastHealthCheck = 0;
const unsigned long HEALTH_CHECK_INTERVAL = 5000;

unsigned long lastWiFiAttempt = 0;
unsigned long lastMqttAttempt = 0;
unsigned long wifiBackoffTime = 1000;
unsigned long mqttBackoffTime = 1000;
const unsigned long MAX_BACKOFF = 30000;

uint8_t wifiFailCount = 0;
uint8_t mqttFailCount = 0;

String lastDisplayedTime = "";
String lastWifiStatus = "";
String lastMqttStatus = "";

void initDisplay();
void drawTopBar();
void updateTopBar();
void drawStatusBar();
void updateStatusBar();
void logToScreen(String message, uint16_t color = ILI9341_WHITE, bool showTimestamp = false);
void clearLogArea();
void updateSystemInfo();

void initBacklight();
void setBacklightLevel(int level);
void fadeBacklightTo(int targetLevel);
void backlightOn();
void backlightOff();
void updateBacklight();

void initButton();
void updateButton();
void handleShortPress();
void handleLongPress();

void connectWiFi();
void connectMQTT();
void checkWiFiQuality();
void mqttCallback(char* topic, byte* payload, unsigned int length);
bool sendMQTTData();

void readBarcode();
void processBarcode();
bool isValidBarcode(String barcode);
void clearScannerBuffer();

void checkContacts();

bool waitForTimeSync(unsigned long timeout);
void setESP32SystemTime(long timestamp);
void setTeamFromHour();

String getDateCSV();
String getTimeCSV();
int getResultNumber(String result);

void rebootSystem();
void healthCheck();

void initNeoPixels();
void setLEDState(LEDState newState);
void updateLEDs();
void setNeoPixelBrightness(uint8_t brightness);
void setLED(uint16_t index, RGBWColor color);
void fillLEDs(RGBWColor color, uint16_t from = 0, uint16_t to = 7);
void clearLEDs();
void updateStatusLEDs();
void animateInit();
void animateConnecting();
void animateTimeSync();
void animateReady();
void animateScanning();
void animateTestRunning();
void animateSending();
void animateSuccess();
void animateError();
void updateWiFiLED();
void updateMQTTLED();

void setup() {
  Serial.begin(115200);
  Serial1.begin(9600);

  initBacklight();
  initButton();
  initNeoPixels();
  
  initDisplay();
  systemStatus = "Demarrage systeme";
  setLEDState(LED_INIT);
  drawTopBar();
  drawStatusBar();

  pinMode(CONTACT_OK, INPUT_PULLUP);
  pinMode(CONTACT_FV, INPUT_PULLUP);
  pinMode(CONTACT_FP, INPUT_PULLUP);

  systemStatus = "Connexion WiFi";
  logToScreen("Initialisation reseau...", COLOR_INFO);
  delay(500);
  connectWiFi();

  mqtt.setServer(mqtt_server, mqtt_port);
  mqtt.setCallback(mqttCallback);
  mqtt.setBufferSize(512);
  systemStatus = "Connexion MQTT";
  connectMQTT();

  systemStatus = "Synchronisation";
  logToScreen("Synchronisation temporelle...", COLOR_WARNING);
  setLEDState(LED_TIME_SYNC);
  
  if (!waitForTimeSync(TIME_SYNC_TIMEOUT)) {
    systemStatus = "ERREUR CRITIQUE";
    logToScreen("ERREUR: Pas de synchronisation !", COLOR_ERROR);
    logToScreen("ARRET DU SYSTEME", COLOR_ERROR);
    Serial.println("ERREUR CRITIQUE: Synchronisation temporelle impossible");
    setLEDState(LED_ERROR);
    while(1) {
      updateLEDs();
      delay(1000);
    }
  }

  logToScreen("Horloge synchronisee avec succes", COLOR_SUCCESS);

  logToScreen("Equipe de production: " + currentTest.team, COLOR_INFO);
  drawTopBar();
  drawStatusBar();

  systemStatus = "Systeme Pret";
  setLEDState(LED_READY);
  logToScreen("=== SYSTEME OPERATIONNEL ===", COLOR_SUCCESS);
  logToScreen("En attente du code-barres...", ILI9341_WHITE);

  updateSystemInfo();
  delay(2000);
}

void loop() {
  mqtt.loop();

  updateButton();
  updateBacklight();
  
  healthCheck();
  updateLEDs();

  static unsigned long lastUIUpdate = 0;
  if (millis() - lastUIUpdate >= 1000) {
    updateSystemInfo();
    lastUIUpdate = millis();
  }

  if (!barcodeReceived) {
    readBarcode();
  }

  if (barcodeReceived) {
    checkContacts();
  }
}

void healthCheck() {
  unsigned long now = millis();
  
  if (now - lastHealthCheck < HEALTH_CHECK_INTERVAL) {
    return;
  }
  lastHealthCheck = now;

  if (WiFi.status() != WL_CONNECTED) {
    if (wifiState == CONN_CONNECTED) {
      logToScreen("WiFi perdu", COLOR_WARNING);
      wifiState = CONN_IDLE;
      wifiFailCount = 0;
      wifiBackoffTime = 1000;
    }
    
    if (wifiState == CONN_IDLE && (now - lastWiFiAttempt >= wifiBackoffTime)) {
      wifiState = CONN_CONNECTING;
      WiFi.begin(ssid, password);
      lastWiFiAttempt = now;
      wifiFailCount++;
      wifiBackoffTime = min(wifiBackoffTime * 2, MAX_BACKOFF);
      logToScreen("WiFi reconnexion (tent: " + String(wifiFailCount) + ")", COLOR_INFO);
    }
  } else {
    if (wifiState != CONN_CONNECTED) {
      wifiState = CONN_CONNECTED;
      wifiFailCount = 0;
      wifiBackoffTime = 1000;
      logToScreen("WiFi reconnecter", COLOR_SUCCESS);
    }
  }

  if (!mqtt.connected()) {
    if (mqttState == CONN_CONNECTED) {
      logToScreen("MQTT perdu", COLOR_WARNING);
      mqttState = CONN_IDLE;
      mqttFailCount = 0;
      mqttBackoffTime = 1000;
    }
    
    if (mqttState == CONN_IDLE && (now - lastMqttAttempt >= mqttBackoffTime)) {
      mqttState = CONN_CONNECTING;
      mqtt.connect(mqtt_client_id, mqtt_user, mqtt_password);
      lastMqttAttempt = now;
      mqttFailCount++;
      mqttBackoffTime = min(mqttBackoffTime * 2, MAX_BACKOFF);
      logToScreen("MQTT reconnexion (tent: " + String(mqttFailCount) + ")", COLOR_INFO);
    }
  } else {
    if (mqttState != CONN_CONNECTED) {
      mqttState = CONN_CONNECTED;
      mqttFailCount = 0;
      mqttBackoffTime = 1000;
      logToScreen("MQTT reconnecter", COLOR_SUCCESS);
    }
  }
}

void initNeoPixels() {
  leds.begin();
  leds.setBrightness(neoPixelBrightness);
  clearLEDs();
  leds.show();
  Serial.println("NeoPixel RGBW initialises - Pin 13 - 10 LEDs");
}

void setNeoPixelBrightness(uint8_t brightness) {
  neoPixelBrightness = constrain(brightness, 0, 255);
  leds.setBrightness(neoPixelBrightness);
  Serial.println("Intensite NeoPixel: " + String(neoPixelBrightness));
}

void setLED(uint16_t index, RGBWColor color) {
  if (index < NEOPIXEL_COUNT) {
    leds.setPixelColor(index, leds.Color(color.r, color.g, color.b, color.w));
  }
}

void fillLEDs(RGBWColor color, uint16_t from, uint16_t to) {
  for (uint16_t i = from; i <= to && i < NEOPIXEL_COUNT; i++) {
    setLED(i, color);
  }
}

void clearLEDs() {
  for (uint16_t i = 0; i < NEOPIXEL_COUNT; i++) {
    leds.setPixelColor(i, 0);
  }
  leds.show();
}

void setLEDState(LEDState newState) {
  currentLEDState = newState;
  animationPhase = 0.0f;
  lastLEDUpdate = 0;
}

void updateLEDs() {
  unsigned long now = millis();
  
  if (now - lastLEDUpdate < 50) return;
  lastLEDUpdate = now;

  switch (currentLEDState) {
    case LED_INIT:
      animateInit();
      break;
    case LED_CONNECTING_WIFI:
      animateConnecting();
      break;
    case LED_TIME_SYNC:
      animateTimeSync();
      break;
    case LED_READY:
      animateReady();
      break;
    case LED_SCANNING:
      animateScanning();
      break;
    case LED_TEST_RUNNING:
      animateTestRunning();
      break;
    case LED_SENDING:
      animateSending();
      break;
    case LED_SUCCESS:
      animateSuccess();
      break;
    case LED_ERROR:
      animateError();
      break;
  }

  updateStatusLEDs();
  leds.show();
}

void animateInit() {
  RGBWColor white = COLOR_WHITE;
  
  uint16_t step = (animationPhase * 8);
  clearLEDs();
  
  for (uint16_t i = 0; i <= step && i < 8; i++) {
    setLED(i, white);
  }

  animationPhase += 0.02f;
  if (animationPhase > 1.0f) animationPhase = 0.0f;
}

void animateConnecting() {
  RGBWColor cyan = COLOR_CYAN;
  
  float pulse = (sin(animationPhase * 6.28f) + 1.0f) / 2.0f;
  uint8_t brightness = (uint8_t)(40 + pulse * 80);
  
  clearLEDs();
  for (uint16_t i = 0; i < 8; i++) {
    uint32_t color = leds.Color(
      (uint8_t)(cyan.r * brightness / 255),
      (uint8_t)(cyan.g * brightness / 255),
      (uint8_t)(cyan.b * brightness / 255),
      (uint8_t)(cyan.w * brightness / 255)
    );
    leds.setPixelColor(i, color);
  }

  animationPhase += 0.025f;
  if (animationPhase > 1.0f) animationPhase = 0.0f;
}

void animateTimeSync() {
  RGBWColor yellow = COLOR_YELLOW;
  
  uint16_t cycle = (uint16_t)(animationPhase * 20) % 4;
  clearLEDs();
  
  if (cycle < 2) {
    for (uint16_t i = 0; i < 4; i++) {
      setLED(i, yellow);
    }
  } else {
    for (uint16_t i = 4; i < 8; i++) {
      setLED(i, yellow);
    }
  }

  animationPhase += 0.033f;
  if (animationPhase > 1.0f) animationPhase = 0.0f;
}

void animateReady() {
  RGBWColor white = COLOR_WHITE;
  
  clearLEDs();
  for (uint16_t i = 0; i < 8; i++) {
    setLED(i, white);
  }
}

void animateScanning() {
  RGBWColor green = COLOR_GREEN;
  
  uint16_t pos = (uint16_t)(animationPhase * 8) % 8;
  clearLEDs();
  setLED(pos, green);

  animationPhase += 0.1f;
  if (animationPhase > 1.0f) animationPhase = 0.0f;
}

void animateTestRunning() {
  RGBWColor white = COLOR_WHITE;
  
  float pulse = (sin(animationPhase * 6.28f) + 1.0f) / 2.0f;
  uint8_t brightness = (uint8_t)(60 + pulse * 80);
  
  clearLEDs();
  for (uint16_t i = 2; i < 6; i++) {
    uint32_t color = leds.Color(
      (uint8_t)(white.r * brightness / 255),
      (uint8_t)(white.g * brightness / 255),
      (uint8_t)(white.b * brightness / 255),
      (uint8_t)(white.w * brightness / 255)
    );
    leds.setPixelColor(i, color);
  }

  animationPhase += 0.033f;
  if (animationPhase > 1.0f) animationPhase = 0.0f;
}

void animateSending() {
  RGBWColor blue = COLOR_BLUE;
  
  uint16_t cycle = (uint16_t)(animationPhase * 30) % 12;
  clearLEDs();
  
  if (cycle < 2 || (cycle >= 4 && cycle < 6) || (cycle >= 8 && cycle < 10)) {
    for (uint16_t i = 0; i < 8; i++) {
      setLED(i, blue);
    }
  }

  animationPhase += 0.033f;
  if (animationPhase > 1.0f) animationPhase = 0.0f;
}

void animateSuccess() {
  RGBWColor green = COLOR_GREEN;
  
  if (animationPhase < 0.67f) {
    fillLEDs(green, 0, 7);
  } else {
    float fadePhase = (animationPhase - 0.67f) / 0.33f;
    uint8_t brightness = (uint8_t)(255 * (1.0f - fadePhase));
    
    clearLEDs();
    for (uint16_t i = 0; i < 8; i++) {
      uint32_t color = leds.Color(brightness, brightness, 0, 0);
      leds.setPixelColor(i, color);
    }
  }

  animationPhase += 0.025f;
  if (animationPhase > 1.0f) {
    animationPhase = 0.0f;
    setLEDState(LED_READY);
  }
}

void animateError() {
  RGBWColor red = COLOR_RED;
  
  uint16_t cycle = (uint16_t)(animationPhase * 20) % 20;
  clearLEDs();
  
  if (cycle < 3 || (cycle >= 5 && cycle < 8)) {
    fillLEDs(red, 0, 7);
  }

  animationPhase += 0.05f;
  if (animationPhase > 1.0f) animationPhase = 0.0f;
}

void updateStatusLEDs() {
  updateWiFiLED();
  updateMQTTLED();
}

void updateWiFiLED() {
  unsigned long now = millis();
  
  if (now - lastWiFiScan >= WIFI_SCAN_INTERVAL) {
    if (WiFi.status() == WL_CONNECTED) {
      wifiRSSI = WiFi.RSSI();
    } else {
      wifiRSSI = 0;
    }
    lastWiFiScan = now;
  }

  RGBWColor color;
  
  if (WiFi.status() != WL_CONNECTED) {
    color = {0, 0, 0, 0};
  } 
  else if (wifiRSSI > -65) {
    color = COLOR_GREEN;
  } 
  else if (wifiRSSI > -75) {
    color = COLOR_YELLOW;
  } 
  else if (wifiRSSI > -85) {
    color = COLOR_ORANGE;
  } 
  else {
    color = COLOR_RED;
  }

  setLED(9, color);
}

void updateMQTTLED() {
  RGBWColor color;
  
  if (mqtt.connected()) {
    color = COLOR_GREEN;
  } else {
    color = COLOR_RED;
  }

  setLED(8, color);
}

void initBacklight() {
  pinMode(TFT_LITE, OUTPUT);
  setBacklightLevel(BACKLIGHT_PWM_MAX);
  backlightTimer = millis();
}

void setBacklightLevel(int level) {
  backlightLevel = constrain(level, BACKLIGHT_PWM_MIN, BACKLIGHT_PWM_MAX);
  analogWrite(TFT_LITE, backlightLevel);
}

void fadeBacklightTo(int targetLevel) {
  while(backlightLevel != targetLevel) {
    if(backlightLevel < targetLevel) {
      backlightLevel += BACKLIGHT_FADE_STEP;
      if(backlightLevel > targetLevel) backlightLevel = targetLevel;
    } else {
      backlightLevel -= BACKLIGHT_FADE_STEP;
      if(backlightLevel < targetLevel) backlightLevel = targetLevel;
    }
    setBacklightLevel(backlightLevel);
    delay(BACKLIGHT_FADE_DELAY);
  }
}

void backlightOn() {
  if(!isBacklightActive) {
    fadeBacklightTo(BACKLIGHT_PWM_MAX);
    isBacklightActive = true;
    logToScreen("Backlight actif pour 1 minute", COLOR_INFO);
  }
  backlightTimer = millis();
}

void backlightOff() {
  if(isBacklightActive) {
    fadeBacklightTo(BACKLIGHT_PWM_MIN);
    isBacklightActive = false;
    logToScreen("Backlight eteint (economie)", COLOR_WARNING);
  }
}

void updateBacklight() {
  if(isBacklightActive && (millis() - backlightTimer > BACKLIGHT_TIMEOUT)) {
    backlightOff();
  }
}

void initButton() {
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  buttonState = BTN_IDLE;
}

void updateButton() {
  bool currentButtonState = digitalRead(BUTTON_PIN);

  if(lastButtonState == HIGH && currentButtonState == LOW) {
    buttonPressStart = millis();
    buttonState = BTN_PRESSED;
    buttonPressed = true;
  }
  else if(lastButtonState == LOW && currentButtonState == HIGH && buttonPressed) {
    unsigned long pressDuration = millis() - buttonPressStart;

    if(pressDuration >= BUTTON_LONG_PRESS) {
      buttonState = BTN_LONG_DETECTED;
      handleLongPress();
    } else if(pressDuration >= BUTTON_SHORT_PRESS) {
      buttonState = BTN_SHORT_DETECTED;
      handleShortPress();
    }

    buttonPressed = false;
    buttonState = BTN_IDLE;
  }

  lastButtonState = currentButtonState;
}

void handleShortPress() {
  backlightOn();
}

void handleLongPress() {
  rebootSystem();
}

void initDisplay() {
  tft.begin();
  tft.setRotation(1);
  tft.fillScreen(COLOR_BACKGROUND);

  for(int i = 0; i < MAX_LOG_LINES; i++) {
    logBuffer[i] = "";
  }

  Serial.println("Ecran ILI9341 initialise - 320x240");
}

void drawTopBar() {
  tft.fillRect(0, 0, SCREEN_WIDTH, TOP_BAR_HEIGHT, COLOR_HEADER);
  
  struct tm timeinfo;
  getLocalTime(&timeinfo);
  
  char dateStr[10];
  char timeStr[10];
  sprintf(dateStr, "%02d/%02d/%02d", timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year % 100);
  sprintf(timeStr, "%02d:%02d:%02d", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
  
  tft.setTextColor(ILI9341_WHITE);
  
  tft.setTextSize(TOP_BAR_TEAM_SIZE);
  tft.setCursor(TOP_BAR_TEAM_X, TOP_BAR_TEAM_Y);
  tft.print(currentTest.team);
  
  tft.drawLine(TOP_BAR_SEPARATOR_1_X, 2, TOP_BAR_SEPARATOR_1_X, 48, ILI9341_WHITE);
  
  tft.setTextSize(TOP_BAR_DATETIME_SIZE);
  tft.setCursor(TOP_BAR_DATE_X, TOP_BAR_DATE_Y);
  tft.print(dateStr);
  tft.setCursor(TOP_BAR_DATE_X, TOP_BAR_TIME_Y);
  tft.print(timeStr);
  
  tft.drawLine(TOP_BAR_SEPARATOR_2_X, 2, TOP_BAR_SEPARATOR_2_X, 48, ILI9341_WHITE);
  
  tft.setTextSize(TOP_BAR_APP_SIZE);
  tft.setCursor(TOP_BAR_APP_X, TOP_BAR_APP_Y1);
  tft.print("MAXLINK");
  tft.setCursor(TOP_BAR_APP_X, TOP_BAR_APP_Y2);
  tft.print("v1.5");
  
  tft.drawLine(0, TOP_BAR_HEIGHT - 1, SCREEN_WIDTH, TOP_BAR_HEIGHT - 1, ILI9341_WHITE);
}

void updateTopBar() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) return;
  
  char timeStr[10];
  sprintf(timeStr, "%02d:%02d:%02d", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
  
  String currentTime = String(timeStr);
  if (currentTime != lastDisplayedTime) {
    lastDisplayedTime = currentTime;
    
    tft.fillRect(TOP_BAR_DATE_X, TOP_BAR_DATE_Y, 170, 40, COLOR_HEADER);
    
    char dateStr[10];
    sprintf(dateStr, "%02d/%02d/%02d", timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year % 100);
    
    tft.setTextSize(TOP_BAR_DATETIME_SIZE);
    tft.setTextColor(ILI9341_WHITE);
    tft.setCursor(TOP_BAR_DATE_X, TOP_BAR_DATE_Y);
    tft.print(dateStr);
    tft.setCursor(TOP_BAR_DATE_X, TOP_BAR_TIME_Y);
    tft.print(timeStr);
  }
}

void drawStatusBar() {
  int statusY = TOP_BAR_HEIGHT;
  tft.fillRect(0, statusY, SCREEN_WIDTH, STATUS_BAR_HEIGHT, COLOR_BACKGROUND);
  tft.setTextSize(1);
  tft.setTextColor(COLOR_INFO);
  
  tft.setCursor(8, statusY + 4);
  tft.print("Status: ");
  tft.setTextColor(ILI9341_WHITE);
  tft.print(systemStatus);
  
  tft.setCursor(140, statusY + 4);
  tft.setTextColor(COLOR_INFO);
  tft.print("WiFi: ");
  tft.setTextColor(wifiStatus == "Connecte" ? COLOR_SUCCESS : COLOR_ERROR);
  tft.print(wifiStatus);
  if(wifiRSSI != 0) {
    tft.setTextColor(COLOR_INFO);
    tft.print(" (");
    tft.print(wifiRSSI);
    tft.print("dBm)");
  }
  
  tft.setCursor(240, statusY + 4);
  tft.setTextColor(COLOR_INFO);
  tft.print("MQTT: ");
  tft.setTextColor(mqttStatus == "Connecte" ? COLOR_SUCCESS : COLOR_ERROR);
  tft.print(mqttStatus);
  
  tft.drawLine(0, statusY + STATUS_BAR_HEIGHT - 1, SCREEN_WIDTH, statusY + STATUS_BAR_HEIGHT - 1, ILI9341_DARKGREY);
}

void updateStatusBar() {
  if (wifiStatus == lastWifiStatus && mqttStatus == lastMqttStatus && systemStatus == systemStatus) {
    return;
  }
  
  lastWifiStatus = wifiStatus;
  lastMqttStatus = mqttStatus;
  
  drawStatusBar();
}

void updateSystemInfo() {
  updateTopBar();
  updateStatusBar();
}

void logToScreen(String message, uint16_t color, bool showTimestamp) {
  for(int i = 0; i < MAX_LOG_LINES - 1; i++) {
    logBuffer[i] = logBuffer[i + 1];
  }

  String newLog = "";
  if (showTimestamp && timeSync) {
    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
      char timeStr[9];
      sprintf(timeStr, "%02d:%02d:%02d", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
      newLog = String(timeStr) + " " + message;
    } else {
      newLog = message;
    }
  } else {
    newLog = message;
  }

  logBuffer[MAX_LOG_LINES - 1] = newLog;

  tft.fillRect(0, LOG_START_Y, SCREEN_WIDTH, LOG_HEIGHT, COLOR_BACKGROUND);

  for(int i = 0; i < MAX_LOG_LINES; i++) {
    if(logBuffer[i].length() > 0) {
      int yPos = LOG_START_Y + (i * LOG_LINE_HEIGHT);
      tft.setCursor(4, yPos);
      tft.setTextSize(1);

      if(i == MAX_LOG_LINES - 1) {
        tft.setTextColor(color, COLOR_BACKGROUND);
      } else {
        tft.setTextColor(ILI9341_LIGHTGREY, COLOR_BACKGROUND);
      }

      String displayMessage = logBuffer[i];
      if (displayMessage.length() > 52) {
        displayMessage = displayMessage.substring(0, 49) + "...";
      }

      tft.println(displayMessage);
    }
  }

  Serial.println("LOG: " + message);
}

void clearLogArea() {
  for(int i = 0; i < MAX_LOG_LINES; i++) {
    logBuffer[i] = "";
  }

  tft.fillRect(0, LOG_START_Y, SCREEN_WIDTH, LOG_HEIGHT, COLOR_BACKGROUND);
}

void connectWiFi() {
  wifiStatus = "Connexion";
  setLEDState(LED_CONNECTING_WIFI);
  logToScreen("Connexion au reseau WiFi...", COLOR_INFO);
  WiFi.begin(ssid, password);

  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(1000);
    Serial.print(".");
    attempts++;

    updateButton();
    updateBacklight();
    updateLEDs();
  }

  if(WiFi.status() == WL_CONNECTED) {
    wifiStatus = "Connecte";
    Serial.println();
    logToScreen("WiFi connecte avec succes !", COLOR_SUCCESS);
    logToScreen("Adresse IP: " + WiFi.localIP().toString(), COLOR_SUCCESS);
    delay(1000);
    checkWiFiQuality();
  } else {
    wifiStatus = "Erreur";
    logToScreen("ERREUR: Connexion WiFi impossible", COLOR_ERROR);
  }
}

void checkWiFiQuality() {
  wifiRSSI = WiFi.RSSI();
  String quality = "";
  uint16_t color = ILI9341_WHITE;

  if (wifiRSSI > -50) {
    quality = "Excellent";
    color = COLOR_SUCCESS;
  } else if (wifiRSSI > -60) {
    quality = "Bon";
    color = COLOR_SUCCESS;
  } else if (wifiRSSI > -70) {
    quality = "Moyen";
    color = COLOR_WARNING;
  } else {
    quality = "Faible";
    color = COLOR_ERROR;
  }

  logToScreen("Signal WiFi: " + quality + " (" + String(wifiRSSI) + " dBm)", color);
}

void connectMQTT() {
  mqttStatus = "Connexion";
  logToScreen("Connexion au serveur MQTT...", COLOR_INFO);

  int attempts = 0;
  while (!mqtt.connected() && attempts < 10) {
    updateButton();
    updateBacklight();
    updateLEDs();

    if (mqtt.connect(mqtt_client_id, mqtt_user, mqtt_password)) {
      mqttStatus = "Connecte";
      logToScreen("MQTT connecte avec succes !", COLOR_SUCCESS);
      mqtt.subscribe("rpi/system/time");
      Serial.println("Abonnement au topic de synchronisation");
      break;
    } else {
      attempts++;
      delay(1000);
      Serial.print(".");
    }
  }

  if(!mqtt.connected()) {
    mqttStatus = "Erreur";
    logToScreen("ERREUR: Connexion MQTT impossible", COLOR_ERROR);
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String message = "";
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }

  Serial.println("MQTT Recu: " + String(topic) + " - " + message);

  if (strcmp(topic, "rpi/system/time") == 0) {
    JsonDocument doc;
    DeserializationError error = deserializeJson(doc, payload, length);

    if (error) {
      Serial.print("Erreur parsing JSON: ");
      Serial.println(error.c_str());
      return;
    }

    if (doc["timestamp"].is<double>() || doc["timestamp"].is<float>() || doc["timestamp"].is<long>() || doc["timestamp"].is<int>()) {
      double timestamp_double = doc["timestamp"];
      long timestamp = (long)timestamp_double;
      Serial.print("Timestamp recu: ");
      Serial.println(timestamp);
      setESP32SystemTime(timestamp);
    }
  }
}

bool sendMQTTData() {
  if (!mqtt.connected()) {
    return false;
  }

  setLEDState(LED_SENDING);
  
  String csvLine = getDateCSV() + "," +
                   getTimeCSV() + "," +
                   currentTest.team + "," +
                   currentTest.barcode + "," +
                   String(getResultNumber(currentTest.result));

  bool success = mqtt.publish(mqtt_topic, csvLine.c_str(), true);

  if (success) {
    Serial.println("MQTT Publie CSV: " + csvLine);
  }

  return success;
}

bool waitForTimeSync(unsigned long timeout) {
  timeSyncStart = millis();
  timeSync = false;
  Serial.println("Attente de synchronisation temporelle...");

  while (!timeSync && (millis() - timeSyncStart < timeout)) {
    mqtt.loop();
    updateButton();
    updateBacklight();
    updateLEDs();

    delay(100);
  }

  return timeSync;
}

void setESP32SystemTime(long timestamp) {
  struct timeval tv;
  tv.tv_sec = timestamp;
  tv.tv_usec = 0;

  if (settimeofday(&tv, NULL) == 0) {
    setenv("TZ", "CET-1CEST,M3.5.0,M10.5.0/3", 1);
    tzset();

    setTeamFromHour();

    timeSync = true;
    Serial.println("Horloge ESP32 synchronisee");
    Serial.print("Timestamp recu: ");
    Serial.println(timestamp);

    mqtt.unsubscribe("rpi/system/time");
    Serial.println("Desabonnement du topic temporel");

    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
      Serial.printf("Heure synchronisee: %02d:%02d:%02d %02d/%02d/%04d\n",
                    timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec,
                    timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year + 1900);
    }
  } else {
    Serial.println("ERREUR: Impossible de synchroniser l'horloge ESP32");
  }
}

void setTeamFromHour() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    currentTest.team = "X";
    return;
  }
  
  int hour = timeinfo.tm_hour;
  if (hour >= 6 && hour < 14) {
    currentTest.team = "A";
  } else if (hour >= 14 && hour < 22) {
    currentTest.team = "B";
  } else {
    currentTest.team = "C";
  }
}

void readBarcode() {
  static unsigned long readStartTime = 0;

  if (barcodeReceived) {
    return;
  }

  while (Serial1.available()) {
    if (readStartTime == 0) {
      readStartTime = millis();
    }

    char c = Serial1.read();

    if (c == '\r' || c == '\n') {
      if (barcodeBuffer.length() > 0) {
        processBarcode();
        barcodeBuffer = "";
        readStartTime = 0;
        return;
      }
    }
    else if (c >= '0' && c <= '9') {
      barcodeBuffer += c;

      if (barcodeBuffer.length() > 30) {
        barcodeBuffer = "";
        readStartTime = 0;
        return;
      }
    }

    if (millis() - readStartTime > SCAN_TIMEOUT) {
      if (barcodeBuffer.length() > 0) {
        processBarcode();
      }
      barcodeBuffer = "";
      readStartTime = 0;
      return;
    }
  }
}

void processBarcode() {
  String barcode = barcodeBuffer;
  barcode.trim();

  unsigned long currentTime = millis();

  if (currentTime - lastScanTime < SCAN_DEBOUNCE) {
    Serial.println("Scan ignore (anti-rebond)");
    return;
  }

  if (barcode == lastBarcode && (currentTime - lastBarcodeTime < BARCODE_COOLDOWN)) {
    Serial.println("Code-barres duplique ignore: " + barcode);
    return;
  }

  if (isValidBarcode(barcode)) {
    currentBarcode = barcode;
    barcodeReceived = true;
    currentTest.barcode = barcode;

    setTeamFromHour();

    lastBarcode = barcode;
    lastBarcodeTime = currentTime;
    lastScanTime = currentTime;

    systemStatus = "Test en cours";
    setLEDState(LED_TEST_RUNNING);

    clearLogArea();
    logToScreen("=== NOUVEAU TEST ===", COLOR_SUCCESS);
    logToScreen("Code-barres: " + barcode, COLOR_INFO);
    logToScreen("Attente du resultat...", COLOR_WARNING);

    Serial.println("Code-barres valide recu: " + barcode);
    clearScannerBuffer();
  } else {
    lastScanTime = currentTime;
    if (barcode.length() > 0) {
      logToScreen("Code invalide: " + barcode, COLOR_ERROR);
      Serial.println("Code invalide ignore: " + barcode + " (len: " + String(barcode.length()) + ")");
    }
  }
}

bool isValidBarcode(String barcode) {
  if (barcode.length() != 26) {
    return false;
  }

  for (int i = 0; i < barcode.length(); i++) {
    if (!isDigit(barcode.charAt(i))) {
      return false;
    }
  }

  return true;
}

void clearScannerBuffer() {
  while (Serial1.available()) {
    Serial1.read();
  }
  Serial.println("Buffer scanner nettoye - Pret pour nouveau scan");
}

void checkContacts() {
  bool contactOK = (digitalRead(CONTACT_OK) == LOW);
  bool contactFV = (digitalRead(CONTACT_FV) == LOW);
  bool contactFP = (digitalRead(CONTACT_FP) == LOW);

  String result = "";
  uint16_t resultColor = ILI9341_WHITE;

  if (contactOK) {
    result = "Poche OK";
    resultColor = COLOR_SUCCESS;
  } else if (contactFV) {
    result = "Fuite Vanne";
    resultColor = COLOR_WARNING;
  } else if (contactFP) {
    result = "Fuite Poche";
    resultColor = COLOR_ERROR;
  }

  if (result != "") {
    currentTest.result = result;
    logToScreen("=== RESULTAT ===", COLOR_INFO);
    logToScreen(result, resultColor);

    if (sendMQTTData()) {
      logToScreen("Donnees transmises !", COLOR_SUCCESS);
      logToScreen("Envoi reussi vers serveur", COLOR_SUCCESS);
      setLEDState(LED_SUCCESS);
      delay(2000);

      clearLogArea();
      clearScannerBuffer();
      currentBarcode = "";
      barcodeReceived = false;
      currentTest = TestData();
      setTeamFromHour();

      barcodeBuffer = "";
      lastBarcode = "";
      lastBarcodeTime = 0;
      lastScanTime = 0;

      systemStatus = "Systeme Pret";
      setLEDState(LED_READY);
      logToScreen("=== PRET POUR NOUVEAU TEST ===", COLOR_SUCCESS);
      logToScreen("En attente du code-barres...", ILI9341_WHITE);
    } else {
      logToScreen("ERREUR: Envoi echoue !", COLOR_ERROR);
      logToScreen("Probleme de transmission", COLOR_ERROR);
      systemStatus = "Erreur MQTT";
      setLEDState(LED_ERROR);
    }
  }
}

void rebootSystem() {
  systemStatus = "Redemarrage";
  setLEDState(LED_ERROR);
  clearLogArea();
  logToScreen("=== REDEMARRAGE PROPRE ===", COLOR_WARNING);
  logToScreen("Fermeture des connexions...", COLOR_INFO);

  backlightOff();

  if (mqtt.connected()) {
    mqtt.disconnect();
    delay(100);
    logToScreen("MQTT deconnecte", COLOR_SUCCESS);
  }

  if (WiFi.status() == WL_CONNECTED) {
    WiFi.disconnect();
    delay(100);
    logToScreen("WiFi deconnecte", COLOR_SUCCESS);
  }

  clearScannerBuffer();
  logToScreen("Redemarrage en cours...", ILI9341_WHITE);
  delay(2000);

  ESP.restart();
}

String getDateCSV() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return "01/01/1970";
  }

  char buffer[32];
  sprintf(buffer, "%02d/%02d/%04d", timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year + 1900);
  return String(buffer);
}

String getTimeCSV() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return "00H00";
  }

  char buffer[6];
  sprintf(buffer, "%02dH%02d", timeinfo.tm_hour, timeinfo.tm_min);
  return String(buffer);
}

int getResultNumber(String result) {
  if (result == "Poche OK") {
    return 1;
  } else if (result == "Fuite Vanne") {
    return 2;
  } else if (result == "Fuite Poche") {
    return 3;
  } else {
    return 0;
  }
}